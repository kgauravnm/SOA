from selenium import webdriver
from selenium.webdriver.edge.service import Service
from selenium.webdriver.edge.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

# Setup
driver_path = r"C:\Automation\driver\msedgedriver.exe"
portal_url = "https://your.portal.url"  # Replace with actual URL

options = Options()
prefs = {
    "download.default_directory": r"C:\Your\Download\Path",  # ✅ Change to your preferred folder
    "download.prompt_for_download": False,
    "download.directory_upgrade": True,
    "safebrowsing.enabled": True
}
options.add_experimental_option("prefs", prefs)
options.add_argument("--start-maximized")

driver = webdriver.Edge(service=Service(driver_path), options=options)
wait = WebDriverWait(driver, 20)
actions = ActionChains(driver)

# Step 1: Login manually
driver.get(portal_url)
print("Please log in via SSO... waiting 30 seconds.")
time.sleep(30)  # Give time for manual login or use element wait
print(driver.page_source)
with open("process_page.html", "w", encoding="utf-8") as f:
    f.write(driver.page_source)
# Step 2: Wait for process list table to load
wait.until(EC.presence_of_element_located((By.XPATH, "//table")))

# Step 3: Loop through all 6 processes
for i in range(1, 7):  # 6 rows
    print(f"\nOpening process #{i}")
    
    # Get the process row and click
    process_row_xpath = f"(//table//tr)[{i+1}]"  # +1 to skip header row
    row = wait.until(EC.element_to_be_clickable((By.XPATH, process_row_xpath)))
    row.click()

    # Step 4: Wait for 'Unmatched' and 'Partially matched' elements
    time.sleep(5)  # Better: wait for specific elements
    
    def get_count(text_label):
        try:
            count_elem = driver.find_element(By.XPATH, f"//span[contains(text(), '{text_label}')]/following-sibling::span")
            return int(count_elem.text.strip())
        except:
            return 0
    
    unmatched = get_count("Unmatched")
    partial = get_count("Partially matched")
    
    print(f"Unmatched: {unmatched}, Partially matched: {partial}")
    
    if unmatched > 0 or partial > 0:
        print("Break found — downloading files...")
        # Click 'Download'
        download_btn = wait.until(EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Download')]")))
        download_btn.click()
        time.sleep(1)

        # Export all trades > Excel
        export_all = wait.until(EC.presence_of_element_located((By.XPATH, "//div[contains(text(), 'Export all trades')]")))
        actions.move_to_element(export_all).perform()
        excel_option = wait.until(EC.element_to_be_clickable((By.XPATH, "//div[contains(text(), 'Excel')]")))
        excel_option.click()
        time.sleep(2)  # Give time for download to start

        # Re-click Download if closed
        download_btn = wait.until(EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Download')]")))
        download_btn.click()
        time.sleep(1)

        # Export breaks only > Excel
        breaks_only = wait.until(EC.presence_of_element_located((By.XPATH, "//div[contains(text(), 'Exports breaks only')]")))
        actions.move_to_element(breaks_only).perform()
        excel_option2 = wait.until(EC.element_to_be_clickable((By.XPATH, "//div[contains(text(), 'Excel')]")))
        excel_option2.click()
        time.sleep(2)

    else:
        print("No break found — skipping download.")

    # Step 5: Go back to process list
    driver.back()
    time.sleep(3)

print("\n✅ All processes checked and files downloaded (if break found).")
driver.quit()




