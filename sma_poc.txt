from selenium import webdriver
from selenium.webdriver.edge.service import Service
from selenium.webdriver.edge.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

# === Setup ===
driver_path = r"C:\Automation\driver\msedgedriver.exe"  # <-- Change if needed
portal_url = "https://your.portal.url"  # <-- Replace with your actual URL
download_dir = r"C:\Your\Download\Path"  # <-- Set to your desired folder

options = Options()
prefs = {
    "download.default_directory": download_dir,
    "download.prompt_for_download": False,
    "download.directory_upgrade": True,
    "safebrowsing.enabled": True
}
options.add_experimental_option("prefs", prefs)
options.add_argument("--start-maximized")

driver = webdriver.Edge(service=Service(driver_path), options=options)
wait = WebDriverWait(driver, 20)
actions = ActionChains(driver)

# === Step 1: Open Portal and Login ===
driver.get(portal_url)
print("🔐 Please complete SSO login... waiting 30 seconds")
time.sleep(30)

# === Step 2: Wait for AG-Grid rows to load ===
rows = wait.until(
    EC.presence_of_all_elements_located((By.XPATH, "//div[@role='row' and contains(@class, 'ag-row')]"))
)
print(f"✅ Found {len(rows)} process rows")

# === Step 3: Loop through the first 6 processes ===
for i in range(min(6, len(rows))):
    print(f"\n➡️ Opening process #{i+1}")
    
    # Refresh rows after each back navigation
    rows = driver.find_elements(By.XPATH, "//div[@role='row' and contains(@class, 'ag-row')]")
    process_cell = rows[i].find_element(By.XPATH, ".//div[@role='gridcell'][1]")
    process_cell.click()
    time.sleep(5)

    # === Step 4: Extract Unmatched and Partially Matched counts ===
    def get_count(label):
        try:
            elem = driver.find_element(By.XPATH, f"//span[contains(text(), '{label}')]/following-sibling::span")
            return int(elem.text.strip())
        except:
            return 0

    unmatched = get_count("Unmatched")
    partial = get_count("Partially matched")
    print(f"🔍 Unmatched = {unmatched}, Partially Matched = {partial}")

    # === Step 5: If break exists, download files ===
    if unmatched > 0 or partial > 0:
        print("📥 Break detected — downloading files...")

        # Click 'Download' button
        download_btn = wait.until(EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Download')]")))
        download_btn.click()
        time.sleep(1)

        # Export All Trades → Excel
        export_all = wait.until(EC.presence_of_element_located((By.XPATH, "//div[contains(text(), 'Export all trades')]")))
        actions.move_to_element(export_all).perform()
        excel_btn = wait.until(EC.element_to_be_clickable((By.XPATH, "//div[contains(text(), 'Excel')]")))
        excel_btn.click()
        time.sleep(3)

        # Re-click Download for Breaks Only
        download_btn = wait.until(EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Download')]")))
        download_btn.click()
        time.sleep(1)

        # Export Breaks Only → Excel
        breaks_only = wait.until(EC.presence_of_element_located((By.XPATH, "//div[contains(text(), 'Exports breaks only')]")))
        actions.move_to_element(breaks_only).perform()
        excel_btn2 = wait.until(EC.element_to_be_clickable((By.XPATH, "//div[contains(text(), 'Excel')]")))
        excel_btn2.click()
        time.sleep(3)

    else:
        print("✅ No breaks found — skipping download.")

    # Go back to process list page
    driver.back()
    time.sleep(5)

# === Done ===
print("\n🎉 All processes completed. Files downloaded (if required).")
driver.quit()